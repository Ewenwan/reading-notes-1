# 算法的乐趣
[time]:<20180926>
* 作者：王晓华
* 来源：gitchat
* 状态：READING | 2018.9.26-
* 特点：
    * 从乐趣出发阐述算法
        * 先展示有趣的问题
        * 再展示优雅的算法
        * 最后归纳设计思路
    * 引入实际问题
        * 训练 **解决问题的能力** -->技术人才的核心技能
    * 涵盖算法种类多
        * 通用类算法
        * 逻辑类/技巧类算法
        * 专业类算法

# 明确目标

- 培养对算法的兴趣
- 培养抽象场景，解决问题的能力
- 更全面的掌握多种算法
- **终极目的：内化算法思想，可以用于解决日常问题，更高效的生活、学习、工作**

# 摘抄笔记

## 序一

> 先用物理学、力学和天文学，才有数学；先有应用场景后有工具，先有探索后有归纳

> 算法作为一门科学是归纳寻求解法的思路，但学习这种归纳法的前提是能体会各种具体算法的用处和效果。意识到这一点，自然也就**破除了诸如“学好数学才能学好算法”之类的迷信。**

- 经典算法：人脑寻求解法->写成程序->计算机依照执行
- 机器学习算法：计算机从数据归纳知识，自己寻求解法
- 过渡：
    - 有监督学习 supervised learning
        - 曲线拟合
    - 无监督学习 unsupervised learning
        - 傅里叶变换
        - 时域频域变换
    - 强化学习 reinforcement learning
        - 棋类算法

## 序二

* 通用类算法
    * 《算法导论》
    * 《数据结构》
* 逻辑类/技巧类算法
    * 梳理逻辑，训练解题思路，解决具体问题
    * 《编程珠玑》
* 专业类算法
    * 图像处理
    * 数据挖掘

> 算法：解决问题的思路和办法

## 前言

> 算法的实质：解决问题

- 构造算法的基础方法
    - 贪婪法
    - 分治法
    - 动态规划法
- 算法设计的三个关键问题
    - 1 模型的建立
        - 数据结构
            - 熟悉特性，多练习
        - 抽象的逻辑思维能力
    - 2 演化算法
    - 3 输入、输出的转换
- 生活中无处不在的算法

- 代码下载
    - [作者博客](http://blog.csdn.net/orbit/)
    - [书籍官网](www.iTuring.cn/book/1605)

[time]:<20180928>
## 第1章 程序员与算法

### 1.1 什么是算法(Algorithm)

> 定义良好的计算过程，取一个or一组值作为输入，并产生一个or一组值作为输出。——《算法导论》

> 从一个步骤开始，按照既定的顺序执行完所有的步骤，最终结束（得到结果）的一个过程。——Knuth《计算机程序设计艺术》

> 一系列计算步骤，将输入数据转换成输出的结果。——Weiss《数据结构与算法分析》

Knuth 算法四大特征
- 确定性
- 有穷性
- 可行性
- 输入和输出

设计算法常用的设计模式
- 贪婪法
- 分治法
- 动态规划法
- 线性规划法
- 搜索和枚举
    - 穷举

常见算法展示形式
- 计算机程序
- 伪代码
- 流程图
- 各种符号和控制表格

常用算法实现方式
- 顺序执行
- 并行执行
    - 分布式计算
- 递归方法
- 迭代方法

算法和数学的关系
- 需要一定的数学基础
- 并不限定于只解决数学问题

> 算法是为解决一个特定的问题而 **精心设计**的一套数学模型以及在这套数学模型上的一系列操作步骤，这些操作步骤将问题描述的输入数据逐步处理、转换，并最后得到一个确定的结果。

### 1.2 程序员必须要会算法吗

- 能够设计解决你面临问题的算法
    - 具备一些相关知识
        - 一定的数学基础
        - 数据结构
        - etc.
    - 创造性思考->解决问题
- 了解领域内的经典问题，会使用现成算法
    - 稳定匹配
    - A*
- 根据实际需要了解一些专业领域算法

很多时候不是用不到，是不会->想不到->用不到

软件被编写出来就是为了解决问题的，程序员的任务就是设计解决这些问题的算法。成功固然高兴，失败也没有什么代价，可以随时卷土重来。**每一个微小的设计都是算法创造性的体现**，即使失败，也比放弃强。

### 1.3 算法的乐趣在哪里

如何解决问题
- 搜索已有的知识和经验
- 寻找关联
- 将未知问题做适当转换
    - 一个or多个问题分别求解
    - 综合得到最终解决方案

如何设计算法
- 数学模型：**设计合适的数据结构**
    - 运用逻辑思维能力
    - 对现实问题进行抽象
    - 抓住主要因素，忽略次要
    - 建立数学模型
- 输入输出
- 算法步骤：对数据进行操作和转换

只有体会到乐趣，才会有动力去主动学习和研究->正向的激励
- 初级：找到特定的算法解决特定的实际问题，解决问题的成就感
- 中级：明白算法的原理并能写出代码，感受到算法本身的乐趣，也能为今后的工作带来便利
- 高级：自己设计算法解决问题

### 1.4 算法与代码

Martin Fowler《重构》21条“坏代码”规律
[重构21条法则](https://blog.csdn.net/shendl/article/details/1462963)
1. Duplicated Code　　代码重复几乎是最常见的异味了。他也是Refactoring的主要目标之一。代码重复往往来自于copy-and-paste的编程风格。与他相对应OAOO是一个好系统的重要标志。
2. Long method　　它是传统结构化的“遗毒”。一个方法应当具有自我独立的意图，不要把几个意图放在一起。
3. Large Class　　大类就是你把太多的责任交给了一个类。这里的规则是One Class One Responsibility.
4. Divergent Change　　一个类里面的内容变化率不同。某些状态一个小时变一次，某些则几个月一年才变一次；某些状态因为这方面的原因发生变化，而另一些则因为其他方面的原因变一次。面向对象的抽象就是把相对不变的和相对变化相隔离。把问题变化的一方面和另一方面相隔离。这使得这些相对不变的可以重用。问题变化的每个方面都可以单独重用。这种相异变化的共存使得重用非常困难。
5. Shotgun Surgery　　这正好和上面相反。对系统一个地方的改变涉及到其他许多地方的相关改变。这些变化率和变化内容相似的状态和行为通常应当放在同一个类中。
6. Feature Envy　对象的目的就是封装状态以及与这些状态紧密相关的行为。如果一个类的方法频繁用get 方法存取其他类的状态进行计算，那么你要考虑把行为移到涉及状态数目最多的那个类。
7. Data Clumps　　某些数据通常像孩子一样成群玩耍：一起出现在很多类的成员变量中，一起出现在许多方法的参数中，这些数据或许应该自己独立形成对象。
8. Primitive Obsession　　面向对象的新手通常习惯使用几个原始类型的数据来表示一个概念。譬如对于范围，他们会使用两个数字。对于Money，他们会用一个浮点数来表示。因为你没有使用对象来表达问题中存在的概念，这使得代码变的难以理解，解决问题的难度大大增加。好的习惯是扩充语言所能提供原始类型，用小对象来表示范围、金额、转化率、邮政编码等等。
9.  Switch Statement　　基于常量的开关语句是OO 的大敌，你应当把他变为子类、state或strategy.
10. Parallel Inheritance Hierarchies　　并行的继承层次是shotgun surgery的特殊情况。因为当你改变一个层次中的某一个类时，你必须同时改变另外一个层次的并行子类。
11. Lazy Class　　一个干活不多的类。类的维护需要额外的开销，如果一个类承担了太少的责任，应当消除它。
12. Speculative Generality　　一个类实现了从未用到的功能和通用性。通常这样的类或方法唯一的用户是testcase.不要犹豫，删除它。
13. Temporary Field　　一个对象的属性可能只在某些情况下才有意义。这样的代码将难以理解。专门建立一个对象来持有这样的孤儿属性，把只和他相关的行为移到该类。最常见的是一个特定的算法需要某些只有该算法才有用的变量。
14. Message Chain　　消息链发生于当一个客户向一个对象要求另一个对象，然后客户又向这另一对象要求另一个对象，再向这另一个对象要求另一个对象，如此如此。这时，你需要隐藏分派。
15. Middle Man　　对象的基本特性之一就是封装，而你经常会通过分派去实现封装。但是这一步不能走得太远，如果你发现一个类接口的一大半方法都在做分派，你可能需要移去这个中间人。
16. Inappropriate Intimacy　　某些类相互之间太亲密，它们花费了太多的时间去砖研别人的私有部分。对人类而言，我们也许不应该太假正经，但我们应当让自己的类严格遵守禁欲主义。
17. Alternative Classes with Different Interfaces　　做相同事情的方法有不同的函数signature，一致把它们往类层次上移，直至协议一致。
18. Incomplete Library Class　　要建立一个好的类库非常困难。我们大量的程序工作都基于类库实现。然而，如此广泛而又相异的目标对库构建者提出了苛刻的要求。库构建者也不是万能的。有时候我们会发现库类无法实现我们需要的功能。而直接对库类的修改有非常困难。这时候就需要用各种手段进行Refactoring.
19. Data Class　对象包括状态和行为。如果一个类只有状态没有行为，那么肯定有什么地方出问题了。
20. Refused Bequest　超类传下来很多行为和状态，而子类只是用了其中的很小一部分。这通常意味着你的类层次有问题。
21. Comments　　经常觉得要写很多注释表示你的代码难以理解。如果这种感觉太多，表示你需要Refactoring。

其他量化指标
- ~~代码注释率~~
- 平均源文件长度
- 平均函数长度
- 平均代码依赖度
- 代码嵌套深度
- 测试用例覆盖度

希望看到的代码：好看，漂亮，整洁，优雅，艺术品，诗一样
- 主观审美需要
- 客观软件质量要求

怎么做到：学习开源代码
- 更好的设计
- 可测试性
- 可维护性

## 第2章 算法设计的基础



## 第3章 算法设计的常用思想



## 参考资料
1. Cormen Introduction to Algorithm 《算法导论》
2. Knuth The Art of Computer Programming 《计算机程序设计艺术》
3. Weiss Data Stuctures and Algorithm Analysis 《数据结构与算法分析》
4. Oram Beautiful Code 《代码之美》
5. Fowler Refactoring:Improving the Design of Existing Code 《重构：改进现有代码的设计》


Gale-Shapley 算法即“求婚-拒绝算法”（propose-and-reject algorithm），以舞伴问题的整个求解过程来看，女孩从接受第一个邀请开始就有了舞伴，并且舞伴会越来越好，因为女孩可以根据自己的排序表确定是否选择更好的舞伴。与此同时，男孩如果被拒绝，他的选择对象会越来越差（因为男孩是根据自己的排序表从好到差开始选择的）。然而实际情况却并不是这样的，Gale-Shapley 算法中“求婚”的一方总是以最佳可能的稳定岗匹配结束，被“求婚”的一方总是以最差可能的稳定匹配结束，因为选择的主动权掌握在“求婚”者手中。现实生活中的道理也是如此，婚姻中男人如果不主动争取，条件好的女孩就会投入别人的怀抱，留给自己的机会就越来越差。学校里那些勇气可嘉、敢于主动示爱的男生，据说都是学过Gale-Shapley 算法的，不信你问问他们。
好好学习算法吧，这关系到人生大事啊！



